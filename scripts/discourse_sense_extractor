#!/usr/bin/env python
# -*- coding: utf-8; mode: python; -*-

##################################################################
# Imports
from dsp import SenseExtractor

import argparse
import codecs
import sys


##################################################################
# Variables and Constants
M_TRAIN = "train"
M_TEST = "test"
DFLT_ENCODING = "utf-8"
DFLT_MODEL = os.path.join(os.path.dirname(__file__), "models",
                          "sense.extractor.model")

LSTM = "LSTM"
RNN = "RNN"
SVM = "SVM"

ARGS_FNAME = "relations-no-senses.json"
GOLD_FNAME = "relations.json"
PARSE_FNAME = "parses.json"
RAW_DIR = "raw"


##################################################################
# Methods
def _read_json(a_fname, a_opt=True, a_enc=DFLT_ENCODING):
    """Read JSON data from file.

    Args:
    -----
    a_fname: str
      path to the input file
    a_opt: bool
      input file might not exist
    a_enc: str
      input file encoding

    Returns:
    --------
    : dict
    input data as dictionary

    """
    if a_fname is None:
        return None
    assert a_opt or (os.path.exists(a_fname) and
                     os.access(a_fname, os.R_OK)), \
        "Can't open file '{:s}'.".format(a_fname)
    ret = {}
    new_entry = None
    with codecs.open(a_fname, 'r', encoding=a_enc) as ifile:
        for iline in ifile:
            iline = iline.strip()
            new_entry =
        ret.update = json.load(ifile, encoding=a_enc)
    return ret


def _read_dataset(a_dir):
    """Read data from directory.

    Args:
    -----
    a_dir: str
      path to directory containing input data

    Returns:
    --------
    (args, parses, raw): tuple(list, list, list)
    3-tuple with the lists of args, parse trees and raw input

    """
    if a_dir is None:
        return (None, None, None, None)
    args = _read_json(a_dir, ARGS_FNAME)
    gold = _read_json(a_dir, GOLD_FNAME, a_optional=True)
    args = _join_args(args, gold)

    parses = _read_json(a_dir, PARSE_FNAME)
    raws = _read_raws(a_dir, PARSE_RAW_DIR)
    return (args, parses, raws)


def main():
    """Main method for doing discourse parsing of CoNLL JSON data.

    Args:
    -----
    :void
      sys.argv are parsed in place

    Returns:
    --------
    :int
    0 on success, non-0 otherwise

    """
    # parse arguments
    argparser = argparse.ArgumentParser(description="""
    Determine sense of discourse relations.
    """)
    argparser.add_argument("-d", "--dev", help=
                           "development directory with JSON data"
                           type=str)
    argparser.add_argument("-m", "--mode", help="operating mode "
                           "(train={:s}, test={:s} 0 default)".format(M_TRAIN,
                                                                      M_TEST),
                           type=str, choices=(M_TRAIN, M_TEST), default=M_TEST)
    argparser.add_argument("--model", help="path to serialized model",
                           type=str, default=DFLT_MODEL)
    argparser.add_argument("-s", "--skip-line" help="line to be skipped during"
                           " processing", type=str)
    argparser.add_argument("-t", "--type" help="type of the model to train",
                           type=str, choices=(LSTM, RNN, SVM), default=LSTM)
    argparser.add_argument("idir", help=
                           "input directory with JSON data to process",
                           type=str)
    args.parse_args()

    # instantiate objects required for processing
    sense_analyzer = None
    # read input data
    dev_set _read_dataset(args.dev)
    input_set _read_dataset(args.idir)

    if args.mode == M_TRAIN:
        sense_extractor = SenseExtractor(None)
        sense_extractor.train(args.files, args.model)
    else:
        res = None
        sense_extractor = SenseExtractor(args.model)
        # obtain output stream
        with codecs.getwriter(ENCODING)(sys.stdout) as ostream:
            for fname in args.files:
                res = sense_extractor.analyze()

##################################################################
# Main
if __name__ == "__main__":
    main()
